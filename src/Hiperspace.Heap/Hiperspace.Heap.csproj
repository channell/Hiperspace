<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>net8.0;net9.0;net10.0</TargetFrameworks>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
    <Title>Hiperspace Heap Store</Title>
    <Description>Hiperspace heap store for session, edge and testing purposes</Description>
    <Copyright>Cepheis Ltd (C) 2023, 2024, 2025</Copyright>
    <LangVersion>13.0</LangVersion>
    <PackageReleaseNotes>https://www.cepheis.com/hiperspace/20251124
## Overview

This release adds the `@AlternateIndex` property to explicitly create an index for views and ad hoc queries that do not *or cannot* be defined in the normal way of using an access path.

### Path Index
Normally indexes are created in `Hiperspace` by defining an extent that uses an attribute to retrieve a list of elements.  The following hilang model defines a *Person* with a *Parent* and an extension *Children* that retrieves all *Person* that have a *Parrent* that refers to this *person*.
```
entity Person (Id : Guid) {Parent : Person} [Children : Person (Parent = this)];
```
The *Children* extent causes an index to be created on *Parent* so that access to *Children* is fast and does not require an scan or all *Person* elements

### Alternate Index
The following model defines two entities {*Product, Order*} that can be viewed as **nodes** in a **graph**. The segment *Item* defined the details of the *Order* with reference to the *Product* being ordered. 

```
entity Product = Node(...) (Id : Guid);
entity Order = Node (...) (Id : Guid) [Items : Item];
segment Item = Edges (From = owner, To = Product, FromType = "Purchase", ToType ="Purchased")
(Line : Int32) 
{
  @AlternateIndex
  Product : Product,
  Quantity : Decimal
};
```
In a **UML** diagram,  *Order* aggregates *Item*, and *Item* is associated with *Product*.  In a **Graph** diagram *Order* and *Product* are both `Nodes` with two `Edge` between them for "Purchase" and "Purchased".

[image]Sites/hiperspace/sample/orderitem.png[/image]

*Product* cannot refer to *Item* because it is a `segment` of its owner (*in this case Order*), and cannot therefore define a *path* from *order* to *Item*. When viewed as a **graph** the Order-&gt;(Purchase)-&gt;Product `Edge` uses the *Item* key to find all edges, but the Product-&gt;(Purchased)-&gt;Order `Edge` needs an `@AlternateIndex` to avoid a scan of all *Items*.

-----

## Result&lt;&gt; enhancement
The Hiperspace [Result](https://github.com/channell/Hiperspace/blob/master/src/Hiperspace/Result.cs) type has been updated to include *Rust-Style* continuation monads that can optionally follow a `.Bind()` (*bind an element with hiperspace*) with:
* `.Then` chaining function
* `.Else` error handling function

```
write.Roles
    .Bind(new Role
    {
        Name = role,
        RoleName = role,
    })
    .Then(r =&gt;
    {
        Log?.LogInformation($"Added missing role {r.Name}");
        return Result.Ok(r);
    })
    .Else(r =&gt; Log?.LogError($"Failed to bind role {r.Value.Name} with status {r.Status} and reason {r.Reason}"));
```</PackageReleaseNotes>
    <PackageLicenseExpression>GPL-2.0-or-later</PackageLicenseExpression>
    <PackageRequireLicenseAcceptance>True</PackageRequireLicenseAcceptance>
    <PackageReadmeFile>readme.md</PackageReadmeFile>
    <Authors>Stephen Channell</Authors>
    <Company>Cepheis Ltd</Company>
    <PackageProjectUrl>https://www.cepheis.com/hiperspace/Hiperspace-Heap</PackageProjectUrl>
    <PackageIcon>Hiper.png</PackageIcon>
    <RepositoryUrl>https://github.com/channell/Hiperspace/tree/master/src/Hiperspace.Heap</RepositoryUrl>
  </PropertyGroup>
  <ItemGroup>
    <None Include="..\Hiper.png">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Nerdbank.GitVersioning">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="readme.md">
      <Pack>True</Pack>
      <PackagePath>\</PackagePath>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Hiperspace\Hiperspace.csproj" />
  </ItemGroup>
  <!--
    Upload generated .nupkg files to the local NuGet feed at http://localhost:5000/v3/index.json
    This target only runs when not in CI (i.e., when $(CI) != 'true').
  -->
  <Target Name="UploadToLocalFeed" AfterTargets="Pack" Condition="'$(CI)' != 'true'">
    <!-- Collect .nupkg files from the output directory -->
    <ItemGroup>
      <LocalPackages Include="$(OutputPath)**\*.nupkg" />
    </ItemGroup>

    <!-- Informational message -->
    <Message Importance="high" Text="Preparing to push @(LocalPackages) to local NuGet feed at https://localhost:5001/v3/index.json" Condition=" '@(LocalPackages)' != '' " />
    <Message Importance="low" Text="No local packages found to push from $(OutputPath)" Condition=" '@(LocalPackages)' == '' " />

    <!-- Push each package found to the local feed. Uses batching so Exec runs per package. -->
    <Exec Command="dotnet nuget push &quot;%(LocalPackages.Identity)&quot; --source &quot;https://localhost:5001/v3/index.json&quot; --api-key &quot;local&quot; --skip-duplicate"
          Condition=" '@(LocalPackages)' != '' " />
  </Target>
</Project>