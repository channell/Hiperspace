## Overview

This release adds the `@AlternateIndex` property to explicitly create an index for views and ad hoc queries that do not *or cannot* be defined in the normal way of using an access path.

### Path Index
Normally indexes are created in `Hiperspace` by defining an extent that uses an attribute to retrieve a list of elements.  The following hilang model defines a *Person* with a *Parent* and an extension *Children* that retrieves all *Person* that have a *Parrent* that refers to this *person*.
```
entity Person (Id : Guid) {Parent : Person} [Children : Person (Parent = this)];
```
The *Children* extent causes an index to be created on *Parent* so that access to *Children* is fast and does not require an scan or all *Person* elements

### Alternate Index
The following model defines two entities {*Product, Order*} that can be viewed as **nodes** in a **graph**. The segment *Item* defined the details of the *Order* with reference to the *Product* being ordered. 

```
entity Product = Node(...) (Id : Guid);
entity Order = Node (...) (Id : Guid) [Items : Item];
segment Item = Edges (From = owner, To = Product, FromType = "Purchase", ToType ="Purchased")
(Line : Int32) 
{
  @AlternateIndex
  Product : Product,
  Quantity : Decimal
};
```
In a **UML** diagram,  *Order* aggregates *Item*, and *Item* is associated with *Product*.  In a **Graph** diagram *Order* and *Product* are both `Nodes` with two `Edge` between them for "Purchase" and "Purchased".

[image]Sites/hiperspace/sample/orderitem.png[/image]

*Product* cannot refer to *Item* because it is a `segment` of its owner (*in this case Order*), and cannot therefore define a *path* from *order* to *Item*. When viewed as a **graph** the Order->(Purchase)->Product `Edge` uses the *Item* key to find all edges, but the Product->(Purchased)->Order `Edge` needs an `@AlternateIndex` to avoid a scan of all *Items*.

-----

## Result<> enhancement
The Hiperspace [Result](https://github.com/channell/Hiperspace/blob/master/src/Hiperspace/Result.cs) type has been updated to include *Rust-Style* continuation monads that can optionally follow a `.Bind()` (*bind an element with hiperspace*) with:
* `.Then` chaining function
* `.Else` error handling function

```
write.Roles
    .Bind(new Role
    {
        Name = role,
        RoleName = role,
    })
    .Then(r =>
    {
        Log?.LogInformation($"Added missing role {r.Name}");
        return Result.Ok(r);
    })
    .Else(r => Log?.LogError($"Failed to bind role {r.Value.Name} with status {r.Status} and reason {r.Reason}"));
```